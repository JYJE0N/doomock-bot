// src/managers/ModuleManager.js - í†µí•©ëœ ë‹¨ì¼ ë§¤ë‹ˆì € (ë¦¬íŒ©í† ë§)

const logger = require("../utils/Logger");
const { getUserName } = require("../utils/UserHelper");
const TimeHelper = require("../utils/TimeHelper");

class ModuleManager {
  constructor(bot, options = {}) {
    this.bot = bot;
    this.db = options.dbManager || null;
    this.moduleInstances = new Map();
    this.isInitialized = false;

    // ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€
    this.processingCallbacks = new Set();

    // ëª¨ë“ˆ ë ˆì§€ìŠ¤íŠ¸ë¦¬ (ModuleConfig.js í†µí•©)
    this.moduleRegistry = {
      system: { class: "SystemModule", path: "../modules/SystemModule" },
      todo: { class: "TodoModule", path: "../modules/TodoModule" },
      timer: { class: "TimerModule", path: "../modules/TimerModule" },
      worktime: { class: "WorktimeModule", path: "../modules/WorktimeModule" },
      leave: { class: "LeaveModule", path: "../modules/LeaveModule" },
      reminder: { class: "ReminderModule", path: "../modules/ReminderModule" },
      fortune: { class: "FortuneModule", path: "../modules/FortuneModule" },
      weather: { class: "WeatherModule", path: "../modules/WeatherModule" },
      utils: { class: "UtilsModule", path: "../modules/UtilsModule" },
    };

    logger.info("ğŸ”§ ModuleManager ìƒì„±ë¨");
  }

  // ğŸ¯ ì´ˆê¸°í™”
  async initialize() {
    if (this.isInitialized) {
      logger.warn("ModuleManager ì´ë¯¸ ì´ˆê¸°í™”ë¨");
      return;
    }

    try {
      logger.info("âš™ï¸ ModuleManager ì´ˆê¸°í™” ì‹œì‘...");
      await this.loadModules();
      this.isInitialized = true;
      logger.success(
        `âœ… ModuleManager ì´ˆê¸°í™” ì™„ë£Œ (${this.moduleInstances.size}ê°œ ëª¨ë“ˆ)`
      );
    } catch (error) {
      logger.error("âŒ ModuleManager ì´ˆê¸°í™” ì‹¤íŒ¨:", error);
      throw error;
    }
  }

  // ğŸ“¦ ëª¨ë“ˆ ë¡œë“œ
  async loadModules() {
    for (const [key, config] of Object.entries(this.moduleRegistry)) {
      try {
        const ModuleClass = require(config.path);
        const moduleInstance = new ModuleClass(this.bot, {
          dbManager: this.db,
          moduleManager: this,
        });

        // ëª¨ë“ˆ ì´ˆê¸°í™”
        if (moduleInstance.initialize) {
          await moduleInstance.initialize();
        }

        this.moduleInstances.set(config.class, moduleInstance);
        logger.debug(`âœ… ${config.class} ë¡œë“œ ì™„ë£Œ`);
      } catch (error) {
        logger.error(`âŒ ${config.class} ë¡œë“œ ì‹¤íŒ¨:`, error.message);
      }
    }
  }

  // ğŸ¯ ë©”ì‹œì§€ í•¸ë“¤ëŸ¬
  async handleMessage(bot, msg) {
    if (!msg.text) return false;

    // ëª¨ë“  ëª¨ë“ˆì—ê²Œ ë©”ì‹œì§€ ì „ë‹¬ (ìš°ì„ ìˆœìœ„ ìˆœ)
    const moduleOrder = [
      "system",
      "todo",
      "leave",
      "worktime",
      "timer",
      "reminder",
      "fortune",
      "weather",
      "utils",
    ];

    for (const moduleName of moduleOrder) {
      const moduleClass = this.moduleRegistry[moduleName]?.class;
      const module = this.moduleInstances.get(moduleClass);

      if (module?.handleMessage) {
        try {
          const handled = await module.handleMessage(bot, msg);
          if (handled) {
            logger.debug(`ğŸ“¬ ë©”ì‹œì§€ê°€ ${moduleClass}ì—ì„œ ì²˜ë¦¬ë¨`);
            return true;
          }
        } catch (error) {
          logger.error(`âŒ ${moduleClass} ë©”ì‹œì§€ ì²˜ë¦¬ ì˜¤ë¥˜:`, error);
        }
      }
    }

    return false;
  }

  // ğŸ¯ ì½œë°± í•¸ë“¤ëŸ¬ (í•œ ê³³ì—ì„œë§Œ ì²˜ë¦¬)
  async handleCallback(callbackQuery) {
    const callbackData = callbackQuery.data;
    const callbackKey = `${callbackQuery.from.id}-${callbackData}`;

    // ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€
    if (this.processingCallbacks.has(callbackKey)) {
      logger.debug("ğŸ”„ ì½œë°± ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€:", callbackKey);
      return false;
    }

    this.processingCallbacks.add(callbackKey);

    try {
      logger.info(`ğŸ“¨ ì½œë°± ë°ì´í„° ìˆ˜ì‹ : ${callbackData}`);

      // ì½œë°± ë°ì´í„° íŒŒì‹±
      const [targetModule, ...actionParts] = callbackData.split(":");
      const subAction = actionParts.join(":") || "menu";

      // íŠ¹ìˆ˜ ì¼€ì´ìŠ¤ ì²˜ë¦¬
      if (targetModule === "main") {
        return await this.handleMainMenu(callbackQuery);
      }

      if (targetModule === "help") {
        return await this.handleHelp(callbackQuery);
      }

      if (targetModule === "system" && subAction === "status") {
        return await this.handleSystemStatus(callbackQuery);
      }

      // ëª¨ë“ˆ ì°¾ê¸°
      const moduleClass = this.findModuleClass(targetModule);
      if (!moduleClass) {
        logger.warn(`âš ï¸ ì•Œ ìˆ˜ ì—†ëŠ” ëª¨ë“ˆ: ${targetModule}`);
        return false;
      }

      const module = this.moduleInstances.get(moduleClass);
      if (!module) {
        logger.warn(`âš ï¸ ëª¨ë“ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${targetModule}`);
        return false;
      }

      // ëª¨ë“ˆ ì½œë°± í˜¸ì¶œ
      if (module.handleCallback) {
        const result = await module.handleCallback(
          this.bot,
          callbackQuery,
          subAction,
          {},
          this // menuManager ëŒ€ì‹  ìê¸° ìì‹  ì „ë‹¬
        );
        return result;
      }

      return false;
    } catch (error) {
      logger.error("âŒ ì½œë°± ì²˜ë¦¬ ì˜¤ë¥˜:", error);
      throw error; // BotControllerì—ì„œ ì²˜ë¦¬í•˜ë„ë¡ ì „íŒŒ
    } finally {
      // ì¤‘ë³µ ë°©ì§€ í•´ì œ
      setTimeout(() => {
        this.processingCallbacks.delete(callbackKey);
      }, 1000);
    }
  }

  // ğŸ  ë©”ì¸ ë©”ë‰´
  async handleMainMenu(callbackQuery) {
    try {
      const userName = getUserName(callbackQuery.from);

      const menuText = `ğŸ  **ë©”ì¸ ë©”ë‰´**

ì•ˆë…•í•˜ì„¸ìš” ${userName}ë‹˜!
ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?`;

      const keyboard = this.createMainMenuKeyboard();

      await this.bot.editMessageText(menuText, {
        chat_id: callbackQuery.message.chat.id,
        message_id: callbackQuery.message.message_id,
        parse_mode: "Markdown",
        reply_markup: keyboard,
      });

      return true;
    } catch (error) {
      logger.error("âŒ ë©”ì¸ ë©”ë‰´ ì²˜ë¦¬ ì˜¤ë¥˜:", error);
      return false;
    }
  }

  // â“ ë„ì›€ë§
  async handleHelp(callbackQuery) {
    try {
      const helpText = `â“ **ë„ì›€ë§**

**ê¸°ë³¸ ëª…ë ¹ì–´:**
â€¢ /start - ë´‡ ì‹œì‘
â€¢ /help - ë„ì›€ë§ ë³´ê¸°
â€¢ /menu - ë©”ì¸ ë©”ë‰´
â€¢ /status - ìƒíƒœ í™•ì¸

**ì£¼ìš” ê¸°ëŠ¥:**
ğŸ“ **í• ì¼ ê´€ë¦¬** - ì‘ì—… ì¶”ê°€/ì™„ë£Œ/ì‚­ì œ
ğŸ”® **ìš´ì„¸** - ì˜¤ëŠ˜ì˜ ìš´ì„¸ í™•ì¸
ğŸŒ¤ï¸ **ë‚ ì”¨** - ì‹¤ì‹œê°„ ë‚ ì”¨ ì •ë³´
â° **íƒ€ì´ë¨¸** - ì‹œê°„ ê´€ë¦¬
ğŸ“… **íœ´ê°€ ê´€ë¦¬** - ì—°ì°¨ ê´€ë¦¬
ğŸ• **ê·¼ë¬´ì‹œê°„** - ì¶œí‡´ê·¼ ê¸°ë¡
ğŸ”” **ë¦¬ë§ˆì¸ë”** - ì•Œë¦¼ ì„¤ì •
ğŸ› ï¸ **ìœ í‹¸ë¦¬í‹°** - í¸ì˜ê¸°ëŠ¥`;

      const keyboard = {
        inline_keyboard: [
          [
            { text: "ğŸ“± ë©”ì¸ ë©”ë‰´", callback_data: "main:menu" },
            { text: "ğŸ“Š ë´‡ ìƒíƒœ", callback_data: "system:status" },
          ],
        ],
      };

      await this.bot.editMessageText(helpText, {
        chat_id: callbackQuery.message.chat.id,
        message_id: callbackQuery.message.message_id,
        parse_mode: "Markdown",
        reply_markup: keyboard,
      });

      return true;
    } catch (error) {
      logger.error("âŒ ë„ì›€ë§ ì²˜ë¦¬ ì˜¤ë¥˜:", error);
      return false;
    }
  }

  // ğŸ“Š ì‹œìŠ¤í…œ ìƒíƒœ
  async handleSystemStatus(callbackQuery) {
    try {
      const uptime = process.uptime();
      const memUsage = process.memoryUsage();

      const statusText = `ğŸ“Š **ì‹œìŠ¤í…œ ìƒíƒœ**

**ë´‡ ì •ë³´:**
â€¢ ë²„ì „: v${process.env.npm_package_version || "3.0.1"}
â€¢ í™˜ê²½: ${process.env.NODE_ENV || "development"}
â€¢ ê°€ë™ ì‹œê°„: ${this.formatUptime(uptime)}

**ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤:**
â€¢ ë©”ëª¨ë¦¬ ì‚¬ìš©: ${Math.round(memUsage.heapUsed / 1024 / 1024)}MB
â€¢ ì´ ë©”ëª¨ë¦¬: ${Math.round(memUsage.heapTotal / 1024 / 1024)}MB

**ëª¨ë“ˆ ìƒíƒœ:**
â€¢ ì´ ëª¨ë“ˆ: ${this.moduleInstances.size}ê°œ
â€¢ í™œì„± ì½œë°±: ${this.processingCallbacks.size}ê°œ`;

      const keyboard = {
        inline_keyboard: [
          [
            { text: "ğŸ”„ ìƒˆë¡œê³ ì¹¨", callback_data: "system:status" },
            { text: "ğŸ”™ ë©”ì¸ ë©”ë‰´", callback_data: "main:menu" },
          ],
        ],
      };

      await this.bot.editMessageText(statusText, {
        chat_id: callbackQuery.message.chat.id,
        message_id: callbackQuery.message.message_id,
        parse_mode: "Markdown",
        reply_markup: keyboard,
      });

      return true;
    } catch (error) {
      logger.error("âŒ ì‹œìŠ¤í…œ ìƒíƒœ ì²˜ë¦¬ ì˜¤ë¥˜:", error);
      return false;
    }
  }

  // ğŸ¨ ë©”ì¸ ë©”ë‰´ í‚¤ë³´ë“œ ìƒì„±
  createMainMenuKeyboard() {
    const menuItems = [];

    // í™œì„±í™”ëœ ëª¨ë“ˆë§Œ í‘œì‹œ
    const moduleButtons = [
      { module: "TodoModule", text: "ğŸ“ í• ì¼ ê´€ë¦¬", callback: "todo:menu" },
      { module: "FortuneModule", text: "ğŸ”® ìš´ì„¸", callback: "fortune:menu" },
      { module: "WeatherModule", text: "ğŸŒ¤ï¸ ë‚ ì”¨", callback: "weather:menu" },
      { module: "TimerModule", text: "â° íƒ€ì´ë¨¸", callback: "timer:menu" },
      { module: "UtilsModule", text: "ğŸ› ï¸ ìœ í‹¸ë¦¬í‹°", callback: "utils:menu" },
      { module: "LeaveModule", text: "ğŸ“… íœ´ê°€ ê´€ë¦¬", callback: "leave:menu" },
      {
        module: "WorktimeModule",
        text: "ğŸ• ê·¼ë¬´ì‹œê°„",
        callback: "worktime:menu",
      },
      {
        module: "ReminderModule",
        text: "ğŸ”” ë¦¬ë§ˆì¸ë”",
        callback: "reminder:menu",
      },
    ];

    for (const btn of moduleButtons) {
      if (this.moduleInstances.has(btn.module)) {
        menuItems.push({ text: btn.text, callback_data: btn.callback });
      }
    }

    // 2ì—´ë¡œ ë°°ì¹˜
    const keyboard = [];
    for (let i = 0; i < menuItems.length; i += 2) {
      const row = [menuItems[i]];
      if (i + 1 < menuItems.length) {
        row.push(menuItems[i + 1]);
      }
      keyboard.push(row);
    }

    // ì‹œìŠ¤í…œ ë©”ë‰´ ì¶”ê°€
    keyboard.push([
      { text: "ğŸ“Š ì‹œìŠ¤í…œ ìƒíƒœ", callback_data: "system:status" },
      { text: "â“ ë„ì›€ë§", callback_data: "help" },
    ]);

    return { inline_keyboard: keyboard };
  }

  // ğŸ” ëª¨ë“ˆ í´ë˜ìŠ¤ ì°¾ê¸°
  findModuleClass(moduleName) {
    const config = this.moduleRegistry[moduleName];
    return config ? config.class : null;
  }

  // ğŸ• ì‹œê°„ í¬ë§·
  formatUptime(seconds) {
    const days = Math.floor(seconds / 86400);
    const hours = Math.floor((seconds % 86400) / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);

    if (days > 0) {
      return `${days}ì¼ ${hours}ì‹œê°„ ${minutes}ë¶„`;
    } else if (hours > 0) {
      return `${hours}ì‹œê°„ ${minutes}ë¶„`;
    } else {
      return `${minutes}ë¶„`;
    }
  }

  // ğŸ“Š ìƒíƒœ ì¡°íšŒ
  getStatus() {
    const moduleStatuses = {};
    for (const [name, module] of this.moduleInstances) {
      moduleStatuses[name] = module.getStats
        ? module.getStats()
        : { active: true };
    }

    return {
      initialized: this.isInitialized,
      totalModules: this.moduleInstances.size,
      activeCallbacks: this.processingCallbacks.size,
      modules: moduleStatuses,
    };
  }

  // ğŸ§¹ ì •ë¦¬
  async cleanup() {
    logger.info("ğŸ§¹ ModuleManager ì •ë¦¬ ì‹œì‘...");

    for (const [name, module] of this.moduleInstances) {
      try {
        if (module.cleanup) {
          await module.cleanup();
        }
        logger.debug(`âœ… ${name} ì •ë¦¬ ì™„ë£Œ`);
      } catch (error) {
        logger.error(`âŒ ${name} ì •ë¦¬ ì‹¤íŒ¨:`, error);
      }
    }

    this.moduleInstances.clear();
    this.processingCallbacks.clear();
    this.isInitialized = false;

    logger.info("âœ… ModuleManager ì •ë¦¬ ì™„ë£Œ");
  }
}

module.exports = ModuleManager;
